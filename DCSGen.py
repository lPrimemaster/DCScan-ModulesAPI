import pprint
import os
import fnmatch
from pathlib import Path
import re

# WARNING : This file is undocumented and it is advised not to edit its contents unless you know what you are doing.
# Erroneous edits can cause a DCSModules-API compile error.
# Code is messy and hard to read. Might be refactored in the future.
# Essentially, this script allows to custom 'preprocess' the DCS_REGISTER_CALL token and auto generate the
# registry (.cpp .h) files to invoke server functions via tcp.

pp = pprint.PrettyPrinter(indent=0)

curr_dir = os.getcwd()

filenames = []
for root, dirs, files in os.walk(curr_dir):
     for file in files:
     	if fnmatch.fnmatch(file, '*.h') and ('install' or 'build') not in root:
     		filenames.append(os.path.join(root, file))

print('Processing files...')
pp.pprint(filenames)
print('\n\n')

# TODO : Make this token_call an argument
token_call = 'DCS_REGISTER_CALL'

# TODO : Document (remember default parameters cannot be used [value must be passed via args])

func = []
return_type = []
header_def = []
args_name = []

for fnm in filenames:
	lst = []
	with open(fnm, 'r') as f:
		lst = f.readlines()

	nlst = []
	p = ''

	# Clean file up
	# Remove comments and includes
	for v in lst:
		ns = v.lstrip().replace('\n', '')

		if not ns:
			continue

		if(ns.startswith('/*') or ns.startswith('*') or ns.startswith('//') or ns.startswith('#')):
			continue

		if(not ns.endswith(';') and not (ns.endswith('}') or ns.endswith('{'))):
			p += (' ' + ns)
			continue

		nlst.append((p + ' ' + ns).lstrip(' '))
		p = ''

	f_prefix = []
	oc = {}
	scope = ''
	for v in nlst:
		if (v.startswith('namespace') or
		 v.startswith('class') or
		 v.startswith('struct')):
			scope = v.split(' ')[1]
			f_prefix.append(scope)
			oc[scope] = 1
		elif scope:
			if ('{' in v):
				oc[scope] += 1
			elif ('}' in v):
				oc[scope] -= 1

			if (oc[scope] == 0 and len(f_prefix) > 0):
				f_prefix.pop()
				if(len(f_prefix) > 0):
					scope = f_prefix[-1]

		if v.startswith(token_call):
			# Get function name with scope
			func.append('::'.join(f_prefix) + '::' + v.split('(')[-2].split(' ')[-1])


			# Get function return and params
			f_raw_types = [y.strip() for y in re.findall('\((.*?)\)', v, re.DOTALL)[0].split(',')]
			if f_raw_types[0] != 'void':
				return_type.append(f_raw_types[0])
			else:
				return_type.append('')
			if(len(f_raw_types) > 1):
				args_name.append([a for a in f_raw_types[1:]])
			else:
				args_name.append([''])


			# Get function header dep
			header_def.append(fnm)



print('Registering functions:')
pp.pprint('Signature: {0}'.format(func))
pp.pprint('Return types: {0}'.format(return_type))
pp.pprint('Arguments: {0}'.format(args_name))
pp.pprint('Headers: {0}'.format(header_def))

HEADER = '''////////////////////////////////////////
//    THIS FILE WAS AUTOGENERATED     //
//  ANY MODIFICATIONS WILL BE ERASED  //
////////////////////////////////////////
// Generated by the DCS pre-processor //
////////////////////////////////////////
'''
DEC = '''
#pragma once
#include "exports.h"
#include <unordered_map>
#include <functional>
#include <any>
#include "../DCS_Utils/include/DCS_ModuleUtils.h"

$0

#define SV_CALL_NULL 0x0
$1

#define SV_ARG_NULL 0x0
$2

namespace DCS {

	/**
	 * \\brief Autogenerated class responsible for registering any function calls that might be
	 * requested via tcp/ip. 
	 *
	 * An hash table is auto generated via the ''' + token_call + ''' token.
	 * Any function declarated with it shall be registered in the hash table and attributed an id callable
	 * via the Registry::Execute*() function family.
	 *
	 */
	class Registry {
	public:
		struct SVParams;
		struct SVReturn;

		static const u16 Get(const char* func_signature)
		{
			u16 val = 0;
			auto it = id.find(func_signature);
			if (it != id.end())
				val = it->second;
			else
				LOG_ERROR("Function signature (%s) not found.", func_signature);
			return val;
		}

		static DCS_API SVReturn Execute(SVParams params);

		static DCS_API const SVParams GetParamsFromData(const unsigned char* payload, i32 size);
	private:
		template<typename T>
		static inline T convert_from_byte(const unsigned char* data, i32 offset, i32 size)
		{
			if(offset >= size)
			{
				LOG_ERROR("Data conversion overflow.");
				return T();
			}

			return *((T*)(data + offset));
		}

		inline static std::unordered_map<const char*, u16> id = 
		{
			$3
		};

	public:
		struct DCS_API SVParams
		{
		public:
			friend class Registry;

			const u8 getOpcode() const
			{
				return opcode;
			}

			const u16 getFunccode() const
			{
				return fcode;
			}

			template<typename T>
			const T getArg(u64 i) const
			{
				T rv;
				try 
				{
				    rv = std::any_cast<T>(args.at(i));
				}
				catch(const std::bad_any_cast& e) 
				{
					LOG_ERROR("Bad SVParams getArg(%d) %s.", i, e.what());
				}
				return rv;
			}

		private:
			SVParams(u8 oc, u16 fc, std::vector<std::any> args) : opcode(oc), fcode(fc), args(args) {  }

		private:

			u8 opcode;
			u16 fcode;
#pragma warning( push )
#pragma warning( disable : 4251 )
			std::vector<std::any> args;
#pragma warning( pop )
		};

		struct DCS_API SVReturn
		{
		public:
			friend class Registry;

			template<typename T>
			T cast() const
			{
				T rv;
				try 
				{
				    rv = std::any_cast<T>(value);
				}
				catch(const std::bad_any_cast& e) 
				{
					LOG_ERROR("Bad SVReturn cast %s.", e.what());
				}
				return rv;
			}

		private:
			SVReturn(std::any value) : value(value) {  }
			SVReturn() {  }

			template<typename T>
			SVReturn& operator=(T&& val)
			{
				value = val;
				return *this;
			}

		private:
	#pragma warning( push )
#pragma warning( disable : 4251 )
			std::any value;
#pragma warning( pop )
		};
	};
}
'''

DEF = '''
#include "registry.h"

const DCS::Registry::SVParams DCS::Registry::GetParamsFromData(const unsigned char* payload, i32 size)
{
	u8  op_code   = convert_from_byte<u8>(payload, 0, size);  // First byte
	u16 func_code = convert_from_byte<u16>(payload, 1, size); // Second byte
	std::vector<std::any> args;

	// 0000 0000 | 0000 0000 0000 0000 | 0000 0000 ...
	// 0		   1		 2			 3         ...
	// (Opcode )   (     FuncCode    )   (   Args  ...

	// Evaluate arguments
	for(i32 it = 3; it < size;)
	{
		u8 arg_type = convert_from_byte<u8>(payload, it++, size);

		switch(arg_type)
		{
		case SV_ARG_NULL:
			LOG_ERROR("Arg type not recognized.");
			break;
		$0
		default:
			__assume(0); // Hint the compiler to optimize a jump table even further disregarding arg_code checks
		}
	}
	return DCS::Registry::SVParams(op_code, func_code, args);
}

// TODO : error directive if parameter is not registered via token_call 
DCS::Registry::SVReturn DCS::Registry::Execute(DCS::Registry::SVParams params)
{
	SVReturn ret; // A generic return type container
	switch(params.getFunccode())
	{
	case SV_CALL_NULL:
		LOG_ERROR("Function call from SVParams is illegal. Funccode not in hash table.");
		LOG_ERROR("Maybe function signature naming is wrong?");
		break;
	$1
	default:
		__assume(0); // Hint the compiler to optimize a jump table even further disregarding func_code checks
	}
	return ret;
}

'''

switch = []
switch_type = []

hdef = []
defines = []
arg_defines = []

registry = []
number = 1

for hd in header_def:
	hdef.append('#include "' + hd + '"')

for sig in func:
	definition = 'SV_CALL_' + sig.replace('::', '_')
	defines.append('#define ' + definition + ' ' + hex(number))

	fargs_casted = []
	anumber = 0

	if args_name[number-1][0]:
		for a in args_name[number-1]:
			fargs_casted.append('params.getArg<' + a + '>(' + str(anumber) + ')')
			anumber += 1

	switch.append('case ' + definition + ':\n\t\t' + 
		('' if not return_type[number-1] else 'ret = ') +
		sig + '(' + ',\n\t\t\t'.join(fargs_casted) + ');\n\t\tbreak;' )
	registry.append('{"' + sig + '", ' + hex(number) + '}')
	number += 1

# Concat arg_types and remove empty str ('') (if exists)
arg_defines = list(filter(None, list(set(sum(args_name, [])))))

dn = 1
arg_def_all = []
if(len(arg_defines) > 0):
	for a in arg_defines:
		arg_def = 'SV_ARG_' + a.replace('::', '_')
		arg_def_all.append('#define ' + arg_def + ' ' + hex(dn))
		switch_type.append('case ' + arg_def + ':\n\t\t\t' + 
			'args.push_back(convert_from_byte<' + a + '>(payload, it, size));\n\t\t\t' + 
			'it += sizeof(' + a + ');\n\t\t\t' + 'break;')
		dn += 1


with open(curr_dir + '/config/registry.h', 'w') as f:
	f.write(HEADER)

	DEC = DEC.replace('$0', '\n'.join(hdef)) 			# Place necessary func call headers
	DEC = DEC.replace('$1', '\n'.join(defines)) 		# Place func call codes definitions
	DEC = DEC.replace('$2', '\n'.join(arg_def_all)) 	# Place func arg registry codes definitions
	DEC = DEC.replace('$3', ',\n\t\t\t'.join(registry)) # Register function signatures in unordered_map

	f.write(DEC)

with open(curr_dir + '/config/registry.cpp', 'w') as f:
	f.write(HEADER)

	DEF = DEF.replace('$0', '\n\t\t'.join(switch_type)) # Add registered types to parameter cast switch
	DEF = DEF.replace('$1', '\n\t\t\t'.join(switch))	# Add registered functions to func call switch

	f.write(DEF)
