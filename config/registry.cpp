////////////////////////////////////////
//    THIS FILE WAS AUTOGENERATED     //
//  ANY MODIFICATIONS WILL BE ERASED  //
////////////////////////////////////////
// Generated by the DCS pre-processor //
////////////////////////////////////////

#include "registry.h"

const DCS::Registry::SVParams DCS::Registry::GetParamsFromData(const unsigned char* payload, i32 size)
{
	u8  op_code   = convert_from_byte<u8>(payload, 0, size);  // First byte
	u16 func_code = convert_from_byte<u16>(payload, 1, size); // Second byte
	std::vector<std::any> args;

	// 0000 0000 | 0000 0000 0000 0000 | 0000 0000 ...
	// 0		   1		 2			 3         ...
	// (Opcode )   (     FuncCode    )   (   Args  ...

	// Evaluate arguments
	for(i32 it = 3; it < size;)
	{
		u8 arg_type = convert_from_byte<u8>(payload, it++, size);

		switch(arg_type)
		{
		case SV_ARG_NULL:
			LOG_ERROR("Arg type not recognized.");
			break;
		
		default:
			__assume(0); // Hint the compiler to optimize a jump table even further disregarding arg_code checks
		}
	}
	return DCS::Registry::SVParams(op_code, func_code, args);
}

// TODO : error directive if parameter is not registered via token_call 
DCS::Registry::SVReturn DCS::Registry::Execute(DCS::Registry::SVParams params)
{
	SVReturn ret; // A generic return type container
	switch(params.getFunccode())
	{
	case SV_CALL_NULL:
		LOG_ERROR("Function call from SVParams is illegal. Funccode not in hash table.");
		LOG_ERROR("Maybe function signature naming is wrong?");
		break;
	case SV_CALL_DCS_Threading_GetMaxHardwareConcurrency:
		ret = DCS::Threading::GetMaxHardwareConcurrency();
		break;
	default:
		__assume(0); // Hint the compiler to optimize a jump table even further disregarding func_code checks
	}
	return ret;
}

